import postmark from "postmark";
import dotenv from "dotenv";
dotenv.config();
import { prisma } from "#prisma";
import { z } from "zod";

let rawEmailClient = new postmark.ServerClient(process.env.POSTMARK_API_TOKEN);

/**
 * Sends an email using postmark
 * @param {*} options
 * @param {*} options.From
 * @param {*} options.To
 * @param {*} options.Subject
 * @param {*} options.TextBody
 * @param {*} options.HtmlBody
 * @param {*} options.userId
 * @param {*} options.crmPersonId
 * @returns
 */
const sendEmail = async (
  options,
  conversationId = undefined,
  isAutogeneratedResponse = false
) => {
  const schema = z.object({
    From: z.string({
      required_error: "From is a required field",
    }),
    To: z
      .string({
        required_error: "To is a required field",
      })
      .email(),
    Subject: z.string({
      required_error: "Subject is a required field",
    }),
    HtmlBody: z
      .string({
        required_error: "HtmlBody is a required field",
      })
      .optional(),
    TextBody: z.string().default("You have a new email from EventPilot!"),
    userId: z.string().optional(),
    crmPersonId: z.string().optional(),
    Headers: z
      .array(z.object({ Name: z.string(), Value: z.string() }))
      .optional(),
    ReplyTo: z.string().optional(),
  });
  const result = schema.safeParse(options);

  const IS_TEST = result.data.To.includes("eventpilot-test");

  if (!result.success) {
    console.log(options);
    console.error(result.error.issues);
    throw new Error(result.error.issues);
  }

  try {
    if (!options.HtmlBody) {
      options.HtmlBody = options.TextBody.replaceAll("\n", "<br />");
    }
    if (!options.TextBody) {
      options.TextBody = "You have a new email from EventPilot!";
    }

    const res = IS_TEST
      ? {
          MessageID: "test",
        }
      : await rawEmailClient.sendEmail(options);

    const emailRecord = await prisma.email.create({
      data: {
        messageId: res.MessageID,
        from: options.From,
        to: options.To,
        subject: options.Subject,
        userId: options.userId,
        crmPersonId: options.crmPersonId,
        htmlBody: options.HtmlBody,
        textBody: options.TextBody,
        conversationId,
        isAutogeneratedResponse,
      },
    });

    await prisma.logs.create({
      data: {
        type: "EMAIL_SENT",
        userId: options.userId,
        emailId: emailRecord.id,
        crmPersonId: options.crmPersonId,
      },
    });

    return { postmarkResponse: res, emailRecord };
  } catch (e) {
    console.error(e);
    console.log(options);
    throw new Error("Error sending email");
  }
};

export { rawEmailClient, sendEmail };

// eslint-disable-next-line
const test = async () => {
  const res = await sendEmail({
    From: "EventPilot Support <EventPilot@geteventpilot.com>",
    To: "jackgeteventpilot.com",
    Subject: "Test",
    TextBody: "Test",
    HtmlBody: "<h1>Test</h1>",
  });

  console.log(res);
};

// test();
/**
 * Broadcast a simple raw-string email to a list of CRM people using Postmark's broadcast stream.
 * Will persist an Email row and EMAIL_SENT log for each recipient via prisma.sendEmailBatch.
 *
 * @param {Object} params
 * @param {Array<Object>} params.crmPersons - Array of CrmPerson objects (should include id, name, and emails[] if possible)
 * @param {string} params.from - From header (e.g., "Sender <sender@example.com>")
 * @param {string} params.subject - Email subject
 * @param {string} params.body - Raw string body (plain text); HtmlBody is auto-derived
 * @param {string=} params.userId - Optional userId for attribution in logs
 * @returns {Promise<{ postmarkResponses: Array<any>, createdEmails: Array<any>, skipped: Array<{id: string, reason: string}> }>} summary
 */
export const sendBroadcastEmailToCrmPersons = async ({
  crmPersons = [],
  from,
  subject,
  body,
  userId = undefined,
  campaignId = undefined,
}) => {
  if (!Array.isArray(crmPersons)) throw new Error("crmPersons must be an array");
  if (!from) throw new Error("from is required");
  if (!subject) throw new Error("subject is required");
  if (typeof body !== "string") throw new Error("body must be a string");

  const html = body ? body.replaceAll("\n", "<br />") : undefined;

  // Extract one email per person (prefers first non-deleted email)
  const messages = [];
  const indexMap = []; // Track crmPerson association by index
  const skipped = [];

  for (const person of crmPersons) {
    if (!person) continue;
    let email = null;
    // Prefer provided person.emails[]
    if (Array.isArray(person.emails) && person.emails.length) {
      const active = person.emails.find((e) => e && e.email && !e.deleted);
      const any = person.emails.find((e) => e && e.email);
      email = (active || any)?.email || null;
    }
    // Allow fallback if a direct email property was provided
    if (!email && typeof person.email === "string") email = person.email;

    if (!email) {
      skipped.push({ id: person.id, reason: "No email found" });
      continue;
    }

    const toHeader = person.name ? `${person.name} <${email}>` : email;
    messages.push({
      From: from,
      To: toHeader,
      Subject: subject,
      TextBody: body,
      HtmlBody: html,
      MessageStream: "broadcast",
    });
    indexMap.push({ crmPersonId: person.id, toHeader });
  }

  if (messages.length === 0) {
    return { postmarkResponses: [], createdEmails: [], skipped };
  }

  // Send via Postmark batch using the broadcast stream
  let responses = [];
  try {
    // Per-recipient mock for eventpilot-test like single sendEmail
    const isTest = messages.map((m) => String(m.To).includes("eventpilot-test"));
    const realIndices = [];
    const realMessages = [];
    messages.forEach((m, i) => {
      if (!isTest[i]) {
        realIndices.push(i);
        realMessages.push(m);
      }
    });

    const realResponses = realMessages.length
      ? await rawEmailClient.sendEmailBatch(realMessages)
      : [];

    // Rebuild responses in original order, mocking test recipients
    responses = new Array(messages.length);
    let realPtr = 0;
    for (let i = 0; i < messages.length; i++) {
      if (isTest[i]) {
        responses[i] = { MessageID: "test" };
      } else {
        responses[i] = realResponses[realPtr++] || { MessageID: `${Date.now()}-${i}` };
      }
    }
  } catch (e) {
    console.error("[postmark broadcast batch]", e);
    throw new Error("Error sending broadcast email batch");
  }

  // Persist emails + logs in a single transaction
  const createdEmails = await prisma.$transaction(async (tx) => {
    const created = [];
    for (let i = 0; i < responses.length; i++) {
      const messageId = responses[i]?.MessageID || `${Date.now()}-${i}`;
      const toHeader = indexMap[i].toHeader;
      const crmPersonId = indexMap[i].crmPersonId || null;

      const emailRecord = await tx.email.create({
        data: {
          messageId,
          from,
          to: toHeader,
          subject,
          htmlBody: html ?? null,
          textBody: body ?? null,
          userId: userId || null,
          crmPersonId,
          campaignId: campaignId || null,
        },
      });

      await tx.logs.create({
        data: {
          type: "EMAIL_SENT",
          userId: userId || null,
          emailId: emailRecord.id,
          crmPersonId,
        },
      });

      created.push(emailRecord);
    }
    return created;
  });

  return { postmarkResponses: responses, createdEmails, skipped };
};
